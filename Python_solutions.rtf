{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue233;\red151\green0\blue126;\red245\green247\blue249;
\red29\green38\blue42;\red20\green0\blue196;\red73\green17\blue135;\red12\green90\blue1;\red181\green0\blue19;
\red51\green51\blue51;\red0\green0\blue0;\red196\green207\blue212;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c93333;\cssrgb\c66667\c5098\c56863;\cssrgb\c96863\c97647\c98039;
\cssrgb\c14902\c19608\c21961;\cssrgb\c10980\c0\c81176;\cssrgb\c36078\c14902\c60000;\cssrgb\c0\c41569\c0;\cssrgb\c76863\c10196\c8627;
\cssrgb\c25882\c25882\c25882;\cssrgb\c0\c0\c0;\cssrgb\c81176\c84706\c86275;}
\margl1440\margr1440\vieww28600\viewh17520\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 1. Deep Copy of linked list with random pointers\
\
class Solution:\
    def copyRandomList(self, head: 'Node') -> 'Node':\
        node = head\
        while node:\
            node.next = Node(x=node.val, next=node.next)\
            node = node.next.next\
            \
        node = head    \
        while node:\
            if node.random:\
                node.next.random = node.random.next\
            node = node.next.next\
            \
        node = head\
        copy = copyhead = Node(0)\
        while node:\
            copy.next = copy = node.next\
            node.next = node = node.next.next\
            \
        return copyhead.next\
\
\pard\pardeftab720\sl280\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://leetcode.com/problems/copy-list-with-random-pointer/discuss/578598/iterative-%2B-recursive-%2B-hashmap-python"}}{\fldrslt 
\f1 \cf2 \expnd0\expndtw0\kerning0
\ul \ulc2 \outl0\strokewidth0 \strokec2 https://leetcode.com/problems/copy-list-with-random-pointer/discuss/578598/iterative-%2B-recursive-%2B-hashmap-python}}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
2. Merge two sorted linked lists:\
\
class Solution:\
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\
        head = ListNode(None)\
        l3 = head\
        while l1 and l2:\
            head.next = ListNode(min(l1.val,l2.val))\
            if l1.val < l2.val:\
                l1 = l1.next\
            else:\
                l2 = l2.next\
            head = head.next\
        head.next = l1 if l1 else l2\
        return l3.next\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
3. Subtree of another tree:\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 class Solution:\
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:\
        if s is None or t is None:\
            return False\
        elif s is None and t is None:\
            return True\
        elif s.val == t.val and self.inordertraversal(s) == self.inordertraversal(t):\
            return True\
        return self.isSubtree(s.left,t) or self.isSubtree(s.right,t)\
        \
    def inordertraversal(self,root):\
        if root is None:\
            return []\
        else:\
            res = []\
            res = self.inordertraversal(root.left)\
            res.append(root.val)\
            res = res + self.inordertraversal(root.right)\
            return res\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
4. Search 2D matrix\
\
Solution 1:\
def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\
        flag = False\
        for item in matrix:\
            if target in item:\
                flag = True\
                break\
        return flag\
\
Solution 2: \
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 def\cf5 \strokec5  \cf6 \strokec6 searchMatrix\cf7 \strokec7 (self, matrix: List[List[int]], target: int)\cf5 \strokec5  -> bool:\
        \cf3 \strokec3 if\cf5 \strokec5  \cf3 \strokec3 not\cf5 \strokec5  matrix:\
            \cf3 \strokec3 return\cf5 \strokec5  \cf3 \strokec3 False\cf5 \strokec5 \
        rows = len(matrix)\
        cols = len(matrix[\cf6 \strokec6 0\cf5 \strokec5 ])\
        \cf3 \strokec3 if\cf5 \strokec5  \cf3 \strokec3 not\cf5 \strokec5  cols:\
            \cf3 \strokec3 return\cf5 \strokec5  \cf3 \strokec3 False\cf5 \strokec5 \
        \
        left = \cf6 \strokec6 0\cf5 \strokec5 \
        right = rows*cols\cf6 \strokec6 -1\cf5 \strokec5 \
        \
        \cf3 \strokec3 while\cf5 \strokec5  left <= right:\
            mid = (left+right)//\cf6 \strokec6 2\cf5 \strokec5 \
            i = mid //cols\
            j = mid % cols\
            \
            \cf3 \strokec3 if\cf5 \strokec5  matrix[i][j] == target:\
                \cf3 \strokec3 return\cf5 \strokec5  \cf3 \strokec3 True\cf5 \strokec5 \
            \cf3 \strokec3 elif\cf5 \strokec5  matrix[i][j] < target:\
                left = mid + \cf6 \strokec6 1\cf5 \strokec5 \
            \cf3 \strokec3 else\cf5 \strokec5 :\
                right = mid - \cf6 \strokec6 1\cf5 \strokec5 \
        \
        \cf3 \strokec3 return\cf5 \strokec5  \cf3 \strokec3 False\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
5. Two sum\
\
class Solution(object):\
    def twoSum(self, nums, target):\
        """\
        :type nums: List[int]\
        :type target: int\
        :rtype: List[int]\
        """\
        h = \{\}\
        for i, num in enumerate(nums):\
            n = target - num\
            if n not in h:\
                h[num] = i\
            else:\
                return [h[n], i]\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
6. Twosum sorted\
\
class Solution:\
    def twoSum(self, numbers: List[int], target: int) -> List[int]:\
        m = len(numbers) // 2\
        m_value = numbers[m]\
        \
        if m_value > target and numbers[0]>0:\
            return self.twoSum(numbers[:m], target)\
        else:\
            cache = \{\}\
            for i in range(len(numbers)):\
                diff = target - numbers[i]\
                if diff in cache:\
                    return [cache[diff]+1, i+1]\
                cache[numbers[i]] = i\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
7. Favorite song genre\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 def\cf5 \strokec5  \cf6 \strokec6 favouriteGenres\cf7 \strokec7 (userSongs, songGenres)\cf5 \strokec5 :\
  songGenre = \{\}\
  output = \{\}\
\
  \cf8 \strokec8 # build mapping from song -> genre\cf5 \strokec5 \
  \cf3 \strokec3 for\cf5 \strokec5  genre \cf3 \strokec3 in\cf5 \strokec5  songGenres:\
    songs = songGenres[genre]\
    \cf3 \strokec3 for\cf5 \strokec5  song \cf3 \strokec3 in\cf5 \strokec5  songs:\
      songGenre[song] = genre\
\
  \cf3 \strokec3 for\cf5 \strokec5  user \cf3 \strokec3 in\cf5 \strokec5  userSongs:\
    genreCount = \{genre: \cf6 \strokec6 0\cf5 \strokec5  \cf3 \strokec3 for\cf5 \strokec5  genre \cf3 \strokec3 in\cf5 \strokec5  songGenres\}\
    songs = userSongs[user]\
    maxCount = float(\cf9 \strokec9 "-inf"\cf5 \strokec5 )\
    favSongs = []\
\
    \cf3 \strokec3 for\cf5 \strokec5  song \cf3 \strokec3 in\cf5 \strokec5  songs:\
      genre = songGenre[song]\
      genreCount[genre] += \cf6 \strokec6 1\cf5 \strokec5 \
\
      \cf3 \strokec3 if\cf5 \strokec5  genreCount[genre] > maxCount:\
        maxCount = genreCount[genre]\
        favSongs = []\
        favSongs.append(genre)\
\
      \cf3 \strokec3 elif\cf5 \strokec5  genreCount[genre] == maxCount:\
        favSongs.append(genre)\
    output[user] = favSongs\
    \
  \cf3 \strokec3 return\cf5 \strokec5  output\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf5 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
8. TwoSum Amazon:\
Given an int array nums and an int target, find how many unique pairs in the array such that their sum is equal to target. Return the number of pairs.\
Input: nums = [1, 1, 2, 45, 46, 46], target = 47\
Output: 2\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 def\cf5 \strokec5  \cf6 \strokec6 uniqueTwoSum\cf7 \strokec7 (nums, target)\cf5 \strokec5 :\
  ans, comp = set(), set()\
  \cf3 \strokec3 for\cf5 \strokec5  n \cf3 \strokec3 in\cf5 \strokec5  nums:\
    c = target-n\
    \cf3 \strokec3 if\cf5 \strokec5  c \cf3 \strokec3 in\cf5 \strokec5  comp:\
      res = (n, c) \cf3 \strokec3 if\cf5 \strokec5  n > c \cf3 \strokec3 else\cf5 \strokec5  (c, n)\
      \cf3 \strokec3 if\cf5 \strokec5  res \cf3 \strokec3 not\cf5 \strokec5  \cf3 \strokec3 in\cf5 \strokec5  ans:\
        ans.add(res)\
    comp.add(n)\
  \cf3 \strokec3 return\cf5 \strokec5  len(ans)\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
9. Generating spiral matrix\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 class\cf5 \strokec5  \cf7 \strokec7 Solution\cf5 \strokec5 :\
    \cf3 \strokec3 def\cf5 \strokec5  \cf6 \strokec6 spiralOrder\cf7 \strokec7 (self, matrix: List[List[int]])\cf5 \strokec5  -> List[int]:\
        \cf9 \strokec9 """\
        :type matrix: List[List[int]]\
        :rtype: List[int]\
        """\cf5 \strokec5 \
        \
        \cf3 \strokec3 if\cf5 \strokec5  \cf3 \strokec3 not\cf5 \strokec5  matrix:\
            \cf3 \strokec3 return\cf5 \strokec5  \cf3 \strokec3 None\cf5 \strokec5 \
        \
        res = []\
        i, j = \cf6 \strokec6 0\cf5 \strokec5 , \cf6 \strokec6 0\cf5 \strokec5 \
		\cf8 \strokec8 # d[0]: moving direction along a row; d[1]: moving direction along a column\cf5 \strokec5 \
        d = [\cf6 \strokec6 1\cf5 \strokec5 , \cf6 \strokec6 0\cf5 \strokec5 ]\
        m, n = len(matrix), len(matrix[\cf6 \strokec6 0\cf5 \strokec5 ])\
		\cf8 \strokec8 # bounds records the ranges of moves\cf5 \strokec5 \
        bounds = [\cf6 \strokec6 0\cf5 \strokec5 , n - \cf6 \strokec6 1\cf5 \strokec5 , \cf6 \strokec6 1\cf5 \strokec5 , m - \cf6 \strokec6 1\cf5 \strokec5 ]\
        \
		\cf8 \strokec8 # go through each position only once\cf5 \strokec5 \
        \cf3 \strokec3 while\cf5 \strokec5  len(res) < m * n:\
            res.append(matrix[i][j])\
			\cf8 \strokec8 # change the direction when reaching a bound\cf5 \strokec5 \
            \cf3 \strokec3 if\cf5 \strokec5  d[\cf6 \strokec6 0\cf5 \strokec5 ] == \cf6 \strokec6 1\cf5 \strokec5  \cf3 \strokec3 and\cf5 \strokec5  j == bounds[\cf6 \strokec6 1\cf5 \strokec5 ]:\
                d = [\cf6 \strokec6 0\cf5 \strokec5 , \cf6 \strokec6 1\cf5 \strokec5 ]\
                bounds[\cf6 \strokec6 1\cf5 \strokec5 ] = j - \cf6 \strokec6 1\cf5 \strokec5 \
            \cf3 \strokec3 if\cf5 \strokec5  d[\cf6 \strokec6 1\cf5 \strokec5 ] == \cf6 \strokec6 1\cf5 \strokec5  \cf3 \strokec3 and\cf5 \strokec5  i == bounds[\cf6 \strokec6 3\cf5 \strokec5 ]:\
                d = [\cf6 \strokec6 -1\cf5 \strokec5 , \cf6 \strokec6 0\cf5 \strokec5 ]\
                bounds[\cf6 \strokec6 3\cf5 \strokec5 ] = i - \cf6 \strokec6 1\cf5 \strokec5 \
            \cf3 \strokec3 if\cf5 \strokec5  d[\cf6 \strokec6 0\cf5 \strokec5 ] == \cf6 \strokec6 -1\cf5 \strokec5  \cf3 \strokec3 and\cf5 \strokec5  j == bounds[\cf6 \strokec6 0\cf5 \strokec5 ]:\
                d = [\cf6 \strokec6 0\cf5 \strokec5 , \cf6 \strokec6 -1\cf5 \strokec5 ]\
                bounds[\cf6 \strokec6 0\cf5 \strokec5 ] = j + \cf6 \strokec6 1\cf5 \strokec5 \
            \cf3 \strokec3 if\cf5 \strokec5  d[\cf6 \strokec6 1\cf5 \strokec5 ] == \cf6 \strokec6 -1\cf5 \strokec5  \cf3 \strokec3 and\cf5 \strokec5  i == bounds[\cf6 \strokec6 2\cf5 \strokec5 ]:\
                d = [\cf6 \strokec6 1\cf5 \strokec5 , \cf6 \strokec6 0\cf5 \strokec5 ]\
                bounds[\cf6 \strokec6 2\cf5 \strokec5 ] = i + \cf6 \strokec6 1\cf5 \strokec5 \
            \
            i += d[\cf6 \strokec6 1\cf5 \strokec5 ]\
            j += d[\cf6 \strokec6 0\cf5 \strokec5 ]\
            \
        \cf3 \strokec3 return\cf5 \strokec5  res\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
10. Critical Connections:\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 from\cf5 \strokec5  collections \cf3 \strokec3 import\cf5 \strokec5  defaultdict\
\
\cf3 \strokec3 class\cf5 \strokec5  \cf7 \strokec7 Solution(object)\cf5 \strokec5 :\
    \cf3 \strokec3 def\cf5 \strokec5  \cf6 \strokec6 criticalConnections\cf7 \strokec7 (self, n, connections)\cf5 \strokec5 :\
        \cf9 \strokec9 """\
        :type n: int\
        :type connections: List[List[int]]\
        :rtype: List[List[int]]\
        """\cf5 \strokec5 \
        graph = defaultdict(list)\
        \cf3 \strokec3 for\cf5 \strokec5  v \cf3 \strokec3 in\cf5 \strokec5  connections:\
            graph[v[\cf6 \strokec6 0\cf5 \strokec5 ]].append(v[\cf6 \strokec6 1\cf5 \strokec5 ])\
            graph[v[\cf6 \strokec6 1\cf5 \strokec5 ]].append(v[\cf6 \strokec6 0\cf5 \strokec5 ])\
        \
        disc = [\cf3 \strokec3 None\cf5 \strokec5  \cf3 \strokec3 for\cf5 \strokec5  _ \cf3 \strokec3 in\cf5 \strokec5  range(n+\cf6 \strokec6 1\cf5 \strokec5 )]\
        low = [\cf3 \strokec3 None\cf5 \strokec5  \cf3 \strokec3 for\cf5 \strokec5  _ \cf3 \strokec3 in\cf5 \strokec5  range(n+\cf6 \strokec6 1\cf5 \strokec5 )]\
\
        res = []\
        self.cur = \cf6 \strokec6 0\cf5 \strokec5 \
        \
        \cf3 \strokec3 def\cf5 \strokec5  \cf6 \strokec6 dfs\cf7 \strokec7 (node, parent)\cf5 \strokec5 :\
            \cf3 \strokec3 if\cf5 \strokec5  disc[node] \cf3 \strokec3 is\cf5 \strokec5  \cf3 \strokec3 None\cf5 \strokec5 :\
                disc[node] = self.cur\
                low[node] = self.cur\
                self.cur += \cf6 \strokec6 1\cf5 \strokec5 \
                \cf3 \strokec3 for\cf5 \strokec5  n \cf3 \strokec3 in\cf5 \strokec5  graph[node]:\
                    \cf3 \strokec3 if\cf5 \strokec5  disc[n] \cf3 \strokec3 is\cf5 \strokec5  \cf3 \strokec3 None\cf5 \strokec5 :\
                        dfs(n, node)\
                \cf3 \strokec3 if\cf5 \strokec5  parent \cf3 \strokec3 is\cf5 \strokec5  \cf3 \strokec3 not\cf5 \strokec5  \cf3 \strokec3 None\cf5 \strokec5 :\
                    l = min([low[i] \cf3 \strokec3 for\cf5 \strokec5  i \cf3 \strokec3 in\cf5 \strokec5  graph[node] \cf3 \strokec3 if\cf5 \strokec5  i!=parent]+[low[node]])\
                \cf3 \strokec3 else\cf5 \strokec5 :\
                    l = min(low[i] \cf3 \strokec3 for\cf5 \strokec5  i \cf3 \strokec3 in\cf5 \strokec5  graph[node]+[low[node]])\
                low[node] = l\
        \
        dfs(\cf6 \strokec6 1\cf5 \strokec5 , \cf3 \strokec3 None\cf5 \strokec5 )\
        \
        \cf3 \strokec3 for\cf5 \strokec5  v \cf3 \strokec3 in\cf5 \strokec5  connections:\
            \cf3 \strokec3 if\cf5 \strokec5  low[v[\cf6 \strokec6 0\cf5 \strokec5 ]]>disc[v[\cf6 \strokec6 1\cf5 \strokec5 ]] \cf3 \strokec3 or\cf5 \strokec5  low[v[\cf6 \strokec6 1\cf5 \strokec5 ]]>disc[v[\cf6 \strokec6 0\cf5 \strokec5 ]]:\
                res.append(v)\
        \
        \cf3 \strokec3 return\cf5 \strokec5  res\
\pard\pardeftab720\sl420\partightenfactor0

\f1\fs28 \cf10 \cb1 \strokec10 \
\pard\pardeftab720\sl280\partightenfactor0

\fs24 \cf11 \strokec11 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
11. Minimum cost to connect all nodes (Min cost to add new roads)\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 #Kruskal algorithm\
def\cf5 \strokec5  \cf6 \strokec6 compute_min_cost\cf7 \strokec7 (num_nodes, base_mst, poss_mst)\cf5 \strokec5 :\
    uf = \{\}\
\
    \cf8 \strokec8 # create union find for the initial edges given \cf5 \strokec5 \
    \cf3 \strokec3 def\cf5 \strokec5  \cf6 \strokec6 find\cf7 \strokec7 (edge)\cf5 \strokec5 :\
        uf.setdefault(edge, edge)\
        \cf3 \strokec3 if\cf5 \strokec5  uf[edge] != edge:\
            uf[edge] = find(uf[edge])\
        \cf3 \strokec3 return\cf5 \strokec5  uf[edge]\
\
    \cf3 \strokec3 def\cf5 \strokec5  \cf6 \strokec6 union\cf7 \strokec7 (edge1, edge2)\cf5 \strokec5 :\
        uf[find(edge1)] = find(edge2)\
\
    \cf3 \strokec3 for\cf5 \strokec5  e1, e2 \cf3 \strokec3 in\cf5 \strokec5  base_mst:\
        \cf3 \strokec3 if\cf5 \strokec5  find(e1) != find(e2):\
            union(e1, e2)\
\
    \cf8 \strokec8 # sort the new edges by cost\cf5 \strokec5 \
    \cf8 \strokec8 # if an edge is not part of the minimum spanning tree, then include it, else continue\cf5 \strokec5 \
    cost_ret = \cf6 \strokec6 0\cf5 \strokec5 \
    \cf3 \strokec3 for\cf5 \strokec5  c1, c2, cost \cf3 \strokec3 in\cf5 \strokec5  sorted(poss_mst, key=\cf3 \strokec3 lambda\cf5 \strokec5  x : x[\cf6 \strokec6 2\cf5 \strokec5 ]):\
        \cf3 \strokec3 if\cf5 \strokec5  find(c1) != find(c2):\
            union(c1, c2)\
            cost_ret += cost\
\
    \cf3 \strokec3 if\cf5 \strokec5  len(\{find(c) \cf3 \strokec3 for\cf5 \strokec5  c \cf3 \strokec3 in\cf5 \strokec5  uf\}) == \cf6 \strokec6 1\cf5 \strokec5  \cf3 \strokec3 and\cf5 \strokec5  len(uf) == num_nodes:\
        \cf3 \strokec3 return\cf5 \strokec5  cost_ret\
    \cf3 \strokec3 else\cf5 \strokec5 :\
        \cf3 \strokec3 return\cf5 \strokec5  \cf6 \strokec6 -1\cf5 \strokec5 \
\
\
\cf3 \strokec3 if\cf5 \strokec5  __name__ == \cf9 \strokec9 '__main__'\cf5 \strokec5 :\
    n = \cf6 \strokec6 6\cf5 \strokec5 \
    edges = [[\cf6 \strokec6 1\cf5 \strokec5 , \cf6 \strokec6 4\cf5 \strokec5 ], [\cf6 \strokec6 4\cf5 \strokec5 , \cf6 \strokec6 5\cf5 \strokec5 ], [\cf6 \strokec6 2\cf5 \strokec5 , \cf6 \strokec6 3\cf5 \strokec5 ]]\
    new_edges = [[\cf6 \strokec6 1\cf5 \strokec5 , \cf6 \strokec6 2\cf5 \strokec5 , \cf6 \strokec6 5\cf5 \strokec5 ], [\cf6 \strokec6 1\cf5 \strokec5 , \cf6 \strokec6 3\cf5 \strokec5 , \cf6 \strokec6 10\cf5 \strokec5 ], [\cf6 \strokec6 1\cf5 \strokec5 , \cf6 \strokec6 6\cf5 \strokec5 , \cf6 \strokec6 2\cf5 \strokec5 ], [\cf6 \strokec6 5\cf5 \strokec5 , \cf6 \strokec6 6\cf5 \strokec5 , \cf6 \strokec6 5\cf5 \strokec5 ]]\
    print(compute_min_cost(n, edges, new_edges))\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97-\
12. Minimum cost to repair all edges (MST)\
\
Solution 1:\
\
from collections import defaultdict\
import heapq\
\
class Solution:\
    def __init__(self):\
        pass\
    \
    def minCostForRepair(self, n, edges, edgesToRepair):\
        graph=defaultdict(list)\
        addedEdges=set()\
        for edge in edgesToRepair:\
            graph[edge[0]].append((edge[2], edge[1]))\
            graph[edge[1]].append((edge[2], edge[0]))\
            addedEdges.add((edge[0], edge[1]))\
            addedEdges.add((edge[1], edge[0]))\
        for edge in edges:\
            if tuple(edge) not in addedEdges:\
                graph[edge[0]].append((0, edge[1]))\
                graph[edge[1]].append((0, edge[0]))\
\
        res=0\
        priorityQueue=[(0, 1)]\
        heapq.heapify(priorityQueue)\
        visited=set()\
\
        while priorityQueue:\
            minCost, node=heapq.heappop(priorityQueue)\
            if node not in visited:\
                visited.add(node)\
                res+=minCost\
                for cost, connectedNode in graph[node]:\
                    if connectedNode not in visited:\
                        heapq.heappush(priorityQueue, (cost, connectedNode))\
\
        return res\
\
\
\
s = Solution()\
n = 5\
edges = [[1, 2], [2, 3], [3, 4], [4, 5], [1, 5]]\
edgesToRepair = [[1, 2, 12], [3, 4, 30], [1, 5, 8]]\
print(s.minCostForRepair(n, edges, edgesToRepair))\
\
Solution 2:\
\
def minCostForRepair( n, edges,edgesToRepair):\
	edgesToRepair.sort(key= lambda x:x[2])\
	\
	# Build hash table with broken edges in order to skip them\
	# when processing the edges list\
	hm = \{(u, v) for u, v, _ in edgesToRepair\}\
\
	total_cost = 0\
	\
	# every node is a parent of itself\
	parent = [i for i in range(n+1)]\
	rank = [0 for _ in range(n+1)]\
	\
	# finds parent\
	def find(p):\
		if parent[p] != p:\
			parent[p] = find(parent[p])\
		return parent[p]\
	\
	# make "a" as parent of "b"\
	def union(a, b):\
		pa = find(a)\
		pb = find(b)\
\
		# a and b are already in the same set\
		if pa == pb:\
			return False\
\
		# Otherwise: the roots are distinct, then the trees are combined \
		# by attaching the root of one to the root of the other.\
		if rank[pa] < rank[pb]:\
			# swap parents since union by rank always attaches \
			# the shorter tree to the root of the taller tree.\
			pa, pb = pb, pa \
		\
		parent[pb] = pa\
		if rank[pa] == rank[pb]:\
			rank[pa] += 1\
		return True\
\
	# connect the given edges which have no cost\
	for u, v in edges:\
		# check both directions since it is an undirected graph\
		if (u,v) not in hm and (v, u) not in hm: \
			if find(u) != find(v):\
				union(u, v)\
			\
	# connect if they have different different parents\
	for u, v, cost in edgesToRepair:\
		if find(u) != find(v):\
			total_cost += cost\
			union(u, v)\
\
	# find one parent and check if all nodes have the same parent else its not connected\
	group = find(1)\
	for i in range(1,n+1):\
		if find(i) != group:\
			return -1\
	\
	return total_cost\
\
\
n = 5\
edges = [[1, 2], [2, 3], [3, 4], [4, 5], [1, 5]]\
edgesToRepair = [[1, 2, 12], [3, 4, 30], [1, 5, 8]]\
print(minCostForRepair(n, edges, edgesToRepair))\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97-\
13.  Maximum average of subtree\
\
Solution 1:\
\
def maximumAverageSubtree(root):\
        def dfs(root):\
            if not root:\
                return 0, 0, (0, root)\
            leftNum, leftAverage, leftMaxAverage = dfs(root.left)\
            rightNum, rightAverage, RightMaxAverage = dfs(root.right)\
            currNum = leftNum + rightNum + 1\
            currAverage = ((leftNum * leftAverage) + root.val + (rightNum * rightAverage))                  /(1+ leftNum + rightNum)\
            currMaxAverage = (currAverage, root)\
            if leftMaxAverage[0] > currMaxAverage[0]:\
                currMaxAverage = leftMaxAverage\
            if RightMaxAverage[0] > currMaxAverage[0]:\
                currMaxAverage = RightMaxAverage\
            return currNum, currAverage, currMaxAverage\
        return dfs(root)[2][1]\
    \
O(n)\
\
Solution 2:\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 class TreeNode:\
    def __init__(self, val, children):\
        self.val = val\
        self.children = children\
        \
        \
\
class Solution:\
    def maximumAverageSubtree(self, root: TreeNode) -> float:\
        self.dic = \{\}\
        self.inordersum(root)\
        return max(self.dic.items(), key = lambda x: x[1])[0]\
\
    def inordersum(self,root):\
        if root:\
            total = root.val\
            nodeCount = 1\
\
            for child in root.children:\
                childSum,childCount =  self.inordersum(child)\
                total += childSum\
                nodeCount += childCount\
\
\
            avg = (total)/(nodeCount)\
            \
            if nodeCount != 1:\
                self.dic[root.val] = avg\
            return [total,nodeCount]\
        else:\
            return [0,0]\cf5 \strokec5 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97-\

\f3 \cf12 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec12 \
\pard\pardeftab720\sl280\partightenfactor0

\f1 \cf11 \strokec11 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f2\fs26 \cf5 \cb4 \strokec5 14. Longest string made up of only vowels\
\
def longestVowelsOnlySubstring(S):\
	S = S.lower()\
    temp, aux, vowels = 0, [], set('aeiou')\
    # Count the length of each vowel substring\
    for c in S + 'z':\
        if c in vowels:\
            temp += 1\
        elif temp:\
            aux.append(temp)\
            temp = 0\
    # If the first letter is not vowel, you must cut the head\
    if S[0] not in vowels: aux = [0] + aux\
    # If the last letter is not vowel, you must cut the tail\
    if S[-1] not in vowels: aux += [0]\
    # Max length = max head + max tail + max middle\
    return aux[0] + aux[-1] + max(aux[1:-1]) if len(aux) >= 3 else sum(aux)\
\

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97-\

\f2\fs26 \cf5 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 15. Battleship\
\
def battleship(N, s, t):\
    matrix = [[0] * N for _ in range(N)]\
    \
    ships = s.split(",")\
    hits = t.split(" ")\
    for i in range(len(ships)):\
        ships[i] = ships[i].split(" ")\
\
    original = set()\
    for i in range(len(ships)):\
        top_left = ships[i][0]\
        bottom_right = ships[i][1]\
        top_x = int(top_left[:-1])-1\
        top_y = ord(top_left[-1])-65\
        bottom_x = int(bottom_right[:-1])-1\
        bottom_y = ord(bottom_right[-1])-65\
        vertical = bottom_x - top_x + 1\
        horizonal = bottom_y - top_y + 1\
        for m in range(top_x, top_x + vertical):\
            for n in range(top_y, top_y + horizonal):\
                matrix[m][n] = i+1\
        original.add(i+1)\
    \
    hitted = set()\
    for hit in hits:\
        x = int(hit[:-1])-1\
        y = ord(hit[-1])-65\
        if matrix[x][y] != 0:\
            hitted.add(matrix[x][y])\
            matrix[x][y] = 0\
\
    updated = set()\
    for i in range(len(matrix)):\
        for j in range(len(matrix[0])):\
            if matrix[i][j] != 0:\
                updated.add(matrix[i][j])\
\
    sunk = len(original - updated)\
    hitted_but_not_sunk = len(hitted & updated)\
\
    return sunk, hitted_but_not_sunk\
\
\

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97-\
16. Longest string without 3 consecutive characters\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 import\cf5 \strokec5  heapq\
\cf3 \strokec3 class\cf5 \strokec5  \cf7 \strokec7 Solution\cf5 \strokec5 :\
    \cf3 \strokec3 def\cf5 \strokec5  \cf6 \strokec6 longestStringNo3repeats\cf7 \strokec7 (self, A, B, C)\cf5 \strokec5 :\
        pq = [] \cf8 \strokec8 # initialize priority queue as array\cf5 \strokec5 \
        \
        res = \cf9 \strokec9 ""\cf5 \strokec5  \cf8 \strokec8 # initialize final answer as empty string\cf5 \strokec5 \
        \
        \cf3 \strokec3 for\cf5 \strokec5  count, letter \cf3 \strokec3 in\cf5 \strokec5  (A, \cf9 \strokec9 'a'\cf5 \strokec5 ), (B, \cf9 \strokec9 'b'\cf5 \strokec5 ), (C, \cf9 \strokec9 'c'\cf5 \strokec5 ):\
            heapq.heappush(pq, (-count, letter)) \cf8 \strokec8 # setup negative count tuple so that it is a max heap\cf5 \strokec5 \
\
        \cf3 \strokec3 while\cf5 \strokec5  len(pq)>=\cf6 \strokec6 2\cf5 \strokec5 :\
            cur_count1, cur_letter1 = heapq.heappop(pq) \cf8 \strokec8 # pop the largest count\cf5 \strokec5 \
            cur_count2, cur_letter2 = heapq.heappop(pq) \cf8 \strokec8 # pop the 2nd largest\cf5 \strokec5 \
            \
            \cf3 \strokec3 if\cf5 \strokec5  len(res) < \cf6 \strokec6 2\cf5 \strokec5 :\
                res += cur_letter1\
                cur_count1 += \cf6 \strokec6 1\cf5 \strokec5 \
\
            \cf3 \strokec3 elif\cf5 \strokec5  len(res) >= \cf6 \strokec6 2\cf5 \strokec5  \cf3 \strokec3 and\cf5 \strokec5  res[\cf6 \strokec6 -2\cf5 \strokec5 :] != cur_letter1*\cf6 \strokec6 2\cf5 \strokec5 : \cf8 \strokec8 # if the last 2 letters are the same as current letter    \cf5 \strokec5 \
                res += cur_letter1\
                cur_count1 += \cf6 \strokec6 1\cf5 \strokec5 \
\
            \cf3 \strokec3 else\cf5 \strokec5 : \
                res += cur_letter2\
                cur_count2 += \cf6 \strokec6 1\cf5 \strokec5 \
            \
            \cf3 \strokec3 if\cf5 \strokec5  cur_count1 < \cf6 \strokec6 0\cf5 \strokec5 : \cf8 \strokec8 # if there is count left, push the tuple back to pq\cf5 \strokec5 \
                heapq.heappush(pq, (cur_count1, cur_letter1))\
            \cf3 \strokec3 if\cf5 \strokec5  cur_count2 < \cf6 \strokec6 0\cf5 \strokec5 : \cf8 \strokec8 # same for 2nd largest, if there is count left, push the tuple back to pq\cf5 \strokec5 \
                heapq.heappush(pq, (cur_count2, cur_letter2))\
\
        \cf8 \strokec8 # try squeezing in more of the last letter if possible        \cf5 \strokec5 \
        \cf3 \strokec3 if\cf5 \strokec5  pq \cf3 \strokec3 and\cf5 \strokec5  res[\cf6 \strokec6 -1\cf5 \strokec5 ] != pq[\cf6 \strokec6 0\cf5 \strokec5 ][\cf6 \strokec6 1\cf5 \strokec5 ]: \
          last_letter = pq[\cf6 \strokec6 0\cf5 \strokec5 ][\cf6 \strokec6 1\cf5 \strokec5 ]*min(abs(pq[\cf6 \strokec6 0\cf5 \strokec5 ][\cf6 \strokec6 0\cf5 \strokec5 ]), \cf6 \strokec6 2\cf5 \strokec5 ) \cf8 \strokec8 # squeeze in 2 letters\cf5 \strokec5 \
        \cf3 \strokec3 elif\cf5 \strokec5  pq \cf3 \strokec3 and\cf5 \strokec5  res[\cf6 \strokec6 -2\cf5 \strokec5 ] != pq[\cf6 \strokec6 0\cf5 \strokec5 ][\cf6 \strokec6 1\cf5 \strokec5 ] \cf3 \strokec3 and\cf5 \strokec5  res[\cf6 \strokec6 -1\cf5 \strokec5 ] == pq[\cf6 \strokec6 0\cf5 \strokec5 ][\cf6 \strokec6 1\cf5 \strokec5 ]:\
          last_letter = pq[\cf6 \strokec6 0\cf5 \strokec5 ][\cf6 \strokec6 1\cf5 \strokec5 ] \cf8 \strokec8 # squeeze in 1 letter\cf5 \strokec5 \
        \cf3 \strokec3 else\cf5 \strokec5 : last_letter = \cf9 \strokec9 ""\cf5 \strokec5 )\
        \
        \cf3 \strokec3 return\cf5 \strokec5  res+last_letter\
        \
S = Solution()\
print(S.longestStringNo3repeats(\cf6 \strokec6 0\cf5 \strokec5 , \cf6 \strokec6 1\cf5 \strokec5 , \cf6 \strokec6 1\cf5 \strokec5 ))\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97-\
17. Substring of size k with k distinct characters\
\
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 def\cf5 \strokec5  \cf6 \strokec6 substringk\cf7 \strokec7 (s, k)\cf5 \strokec5 :\
    \cf3 \strokec3 if\cf5 \strokec5  \cf3 \strokec3 not\cf5 \strokec5  s \cf3 \strokec3 or\cf5 \strokec5  k == \cf6 \strokec6 0\cf5 \strokec5 :\
        \cf3 \strokec3 return\cf5 \strokec5  []\
    \
    letter, res = \{\}, set()\
    start = \cf6 \strokec6 0\cf5 \strokec5 \
    \cf3 \strokec3 for\cf5 \strokec5  i \cf3 \strokec3 in\cf5 \strokec5  range(len(s)):\
        \cf3 \strokec3 if\cf5 \strokec5  s[i] \cf3 \strokec3 in\cf5 \strokec5  letter \cf3 \strokec3 and\cf5 \strokec5  letter[s[i]] >= start:\
            start = letter[s[i]]+\cf6 \strokec6 1\cf5 \strokec5 \
        letter[s[i]] = i\
        \cf3 \strokec3 if\cf5 \strokec5  i-start+\cf6 \strokec6 1\cf5 \strokec5  == k:\
            res.add(s[start:i+\cf6 \strokec6 1\cf5 \strokec5 ])\
            start += \cf6 \strokec6 1\cf5 \strokec5 \
    \cf3 \strokec3 return\cf5 \strokec5  list(res)\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf5 \

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97-\
18. Count substrings with exactly k distinct characters\
\
def subStringsWithKDistinctCharacters(s, k):\
    s = list(s)\
    \
    def atMost(k):\
        count = collections.defaultdict(int)\
        left = 0\
        ans = 0\
        for right, x in enumerate(s):\
            count[x] += 1\
            while len(count) > k:\
                count[s[left]] -= 1\
                if count[s[left]] == 0:\
                    del count[s[left]]\
                left += 1\
            ans += right - left + 1\
        return ans\
    return atMost(k) - atMost(k-1)\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97-\
19. Zombie matrix / Min hours to send file to all available servers / "rotting oranges"\

\f2\fs26 \cf5 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 \
\pard\pardeftab720\sl400\partightenfactor0
\cf3 \strokec3 from\cf5 \strokec5  collections import deque\
def \cf6 \strokec6 minHours\cf5 \strokec5 (\cf7 \strokec7 rows: \cf3 \strokec3 int\cf7 \strokec7 , columns: \cf3 \strokec3 int\cf7 \strokec7 , grid: List[List[\cf3 \strokec3 int\cf7 \strokec7 ]]\cf5 \strokec5 ) -> \cf3 \strokec3 int\cf5 \strokec5 :\
    \cf3 \strokec3 if\cf5 \strokec5  not grid: return -1\
    RLEN, CLEN = len(grid), len(grid[\cf6 \strokec6 0\cf5 \strokec5 ])\
    q = deque()\
    hours = \cf6 \strokec6 -1\cf5 \strokec5 \
    \
    \cf6 \strokec6 # get adjacents\cf5 \strokec5 \
    def \cf6 \strokec6 neighbors\cf5 \strokec5 (\cf7 \strokec7 pos\cf5 \strokec5 ):\
        r,c = pos\
        \cf3 \strokec3 for\cf5 \strokec5  nr,nc \cf6 \strokec6 in\cf5 \strokec5  (\cf7 \strokec7 (r\cf6 \strokec6 -1\cf7 \strokec7 ,c\cf5 \strokec5 ), (\cf7 \strokec7 r+\cf6 \strokec6 1\cf7 \strokec7 ,c\cf5 \strokec5 ), (\cf7 \strokec7 r,c\cf6 \strokec6 -1\cf5 \strokec5 ), (\cf7 \strokec7 r,c+\cf6 \strokec6 1\cf5 \strokec5 )):\
            \cf3 \strokec3 if\cf5 \strokec5  0 <= nr < RLEN and \cf6 \strokec6 0\cf5 \strokec5  <= nc < CLEN:\
                \cf3 \strokec3 yield\cf5 \strokec5  nr,nc\
        \
    \cf6 \strokec6 # get all zombies!!!\cf5 \strokec5 \
    \cf3 \strokec3 for\cf5 \strokec5  r, row \cf3 \strokec3 in\cf5 \strokec5  \cf6 \strokec6 enumerate\cf5 \strokec5 (\cf7 \strokec7 grid\cf5 \strokec5 ):\
        \cf3 \strokec3 for\cf5 \strokec5  c, val \cf3 \strokec3 in\cf5 \strokec5  \cf6 \strokec6 enumerate\cf5 \strokec5 (\cf7 \strokec7 row\cf5 \strokec5 ):\
            \cf3 \strokec3 if\cf5 \strokec5  val == \cf6 \strokec6 1\cf5 \strokec5 :\
                q.append((r,c))\
    \cf3 \strokec3 while\cf5 \strokec5  q:\
        \cf3 \strokec3 for\cf5 \strokec5  _ \cf3 \strokec3 in\cf5 \strokec5  \cf6 \strokec6 range\cf5 \strokec5 (\cf7 \strokec7 len(q\cf5 \strokec5 )):\
            r,c = q.popleft()\
            \cf3 \strokec3 for\cf5 \strokec5  nr,nc \cf3 \strokec3 in\cf5 \strokec5  \cf6 \strokec6 neighbors\cf5 \strokec5 (\cf7 \strokec7 (r,c\cf5 \strokec5 )):\
                \cf3 \strokec3 if\cf5 \strokec5  grid[nr][nc] == \cf6 \strokec6 0\cf5 \strokec5 :\
                    grid[nr][nc] = \cf6 \strokec6 1\cf5 \strokec5 \
                \cf3 \strokec3 else\cf5 \strokec5 : \cf3 \strokec3 continue\cf5 \strokec5 \
                q.append((nr,nc))\
        hours += \cf6 \strokec6 1\cf5 \strokec5 \
    \cf3 \strokec3 return\cf5 \strokec5  hours\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97-
\f2\fs26 \cf5 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 \
20.Min Cost to Connect Ropes / Min Time to Merge Files [Experienced]\
\
from heapq import heappop, heappush, heapify\
def minCost(ropes):\
  if not ropes: return 0\
  if len(ropes) == 1: return ropes[0]\
  heapify(ropes)\
  cost = 0\
  while len(ropes) > 1:\
    a, b = heappop(ropes), heappop(ropes)\
    cost += a+b\
    if ropes:\
      heappush(ropes, a+b)\
  return cost\

\f0\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97-\

\f2\fs26 \cf5 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 \
}